{
 "className": "io.deephaven.db.v2.by.ComboAggregateFactory",
 "methods": {
  "Agg": "Create an aggregation.\n\n*Overload 1*  \n  :param factory: (io.deephaven.db.v2.by.AggregationStateFactory) - aggregation factory.\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                     the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)\n  \n*Overload 2*  \n  :param factoryType: (io.deephaven.db.v2.by.AggType) - aggregation factory type.\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                     the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggAbsSum": "Create an absolute sum aggregation, equivalent to Table.absSumBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                   the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggArray": "Create an array aggregation, equivalent to Table.by(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                   the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggAvg": "Create an average aggregation, equivalent to Table.avgBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                   the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggCombo": "Create a new ComboAggregateFactory suitable for passing to Table.by(AggregationStateFactory, String...).\n\n:param aggregations: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy...) - the aggregations to compute\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory) a new table with the specified aggregations.",
  "AggCount": "Create an count aggregation, equivalent to Table.countBy(String).\n\n:param resultColumn: (java.lang.String) - the name of the result column containing the count of each group\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggCountDistinct": "Create a distinct count aggregation.\n\n The output column contains the number of distinct values for the input column in that group.\n\n*Overload 1*  \n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                     the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...).  Null values are not counted.\n  \n*Overload 2*  \n  :param countNulls: (boolean) - if true null values are counted as a distinct value, otherwise null values are ignored\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                     the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggDistinct": "Create a distinct aggregation.\n\n The output column contains a DbArrayBase with the distinct values for\n the input column within the group.\n\n*Overload 1*  \n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                     the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...).  Null values are ignored.\n  \n*Overload 2*  \n  :param countNulls: (boolean) - if true, then null values are included in the result, otherwise null values are ignored\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                     the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggFirst": "Create a first aggregation, equivalent to Table.firstBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                   the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggFormula": "Create a formula aggregation.\n\n:param formula: (java.lang.String) - the formula to apply to each group\n:param formulaParam: (java.lang.String) - the parameter name within the formula\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                   the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggLast": "Create a last aggregation, equivalent to Table.lastBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                   the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggMax": "Create a maximum aggregation, equivalent to Table.maxBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                   the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggMed": "Create a median aggregation, equivalent to Table.medianBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                   the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggMin": "Create a minimum aggregation, equivalent to Table.minBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                   the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggPct": "Create a percentile aggregation.\n\n*Overload 1*  \n  :param percentile: (double) - the percentile to calculate\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                     the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)\n  \n*Overload 2*  \n  :param percentile: (double) - the percentile to calculate\n  :param averageMedian: (boolean) - if true, then when the upper values and lower values have an equal size; average the highest\n                        lower value and lowest upper value to produce the median value for integers, longs, doubles,\n                        and floats\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                     the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggSortedFirst": "Create a sorted first aggregation, equivalent to SortedBy.sortedFirstBy(io.deephaven.db.tables.Table, java.lang.String).\n\n*Overload 1*  \n  :param sortColumn: (java.lang.String) - the column to sort by\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                     the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)\n  \n*Overload 2*  \n  :param sortColumns: (java.lang.String[]) - the column to sort by\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                     the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggSortedLast": "Create a sorted last aggregation, equivalent to SortedBy.sortedLastBy(io.deephaven.db.tables.Table, java.lang.String).\n\n*Overload 1*  \n  :param sortColumn: (java.lang.String) - the column to sort by\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                     the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)\n  \n*Overload 2*  \n  :param sortColumns: (java.lang.String[]) - the columns to sort by\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                     the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggStd": "Create a standard deviation aggregation, equivalent to Table.stdBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                   the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggSum": "Create a summation aggregation, equivalent to Table.sumBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                   the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggUnique": "Create a Unique aggregation.\n\n The output column contains a value of the same type as the input column which contains\n\n* The \"no key value\" - if there are no values present \n* The single unique value - if there is only a single value present\n* The \"non unique value\" - if there are more than 1 distinct values present\n\n*Overload 1*  \n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                     the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)\n  \n*Overload 2*  \n  :param countNulls: (boolean) - if true, then null values are included in the result, otherwise null values are ignored\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                     the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...).  Output columns contain null if\n            there are no values present or there are more than 1 distinct values present.\n  \n*Overload 3*  \n  :param countNulls: (boolean) - if true, then null values are included in the result, otherwise null values are ignored\n  :param noKeyValue: (java.lang.Object) - the value to use if there are no values present\n  :param nonUniqueValue: (java.lang.Object) - the value to use if there are more than 1 values present\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                     the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggVar": "Create a variance aggregation, equivalent to Table.varBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                   the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggWAvg": "Create a weighted average aggregation, equivalent to Table.wavgBy(String, String...).\n\n:param weight: (java.lang.String) - the name of the column to use as the weight for the average\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                   the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)",
  "AggWSum": "Create a weighted sum aggregation, equivalent to Table.wsumBy(String, String...).\n\n:param weight: (java.lang.String) - the name of the column to use as the weight for the sum\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n                   the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to ComboAggregateFactory.AggCombo(ComboBy...)"
 },
 "path": "io.deephaven.db.v2.by.ComboAggregateFactory",
 "text": "The ComboAggregateFactory combines one or more aggregations into an operator for use with Table.by(AggregationStateFactory).\n\n The intended use of this class is to call the ComboAggregateFactory.AggCombo(ComboBy...) method with a set of aggregations\n defined by:\n \n* ComboAggregateFactory.AggMin(java.lang.String...)\n* ComboAggregateFactory.AggMax(java.lang.String...)\n* ComboAggregateFactory.AggSum(java.lang.String...)\n* ComboAggregateFactory.AggAbsSum(java.lang.String...)\n* ComboAggregateFactory.AggVar(java.lang.String...)\n* ComboAggregateFactory.AggAvg(java.lang.String...)\n* ComboAggregateFactory.AggWAvg(java.lang.String, java.lang.String...)\n* ComboAggregateFactory.AggWSum(java.lang.String, java.lang.String...)\n* ComboAggregateFactory.AggMed(java.lang.String...)\n* ComboAggregateFactory.AggPct(double, java.lang.String...)\n* ComboAggregateFactory.AggStd(java.lang.String...)\n* ComboAggregateFactory.AggFirst(java.lang.String...)\n* ComboAggregateFactory.AggLast(java.lang.String...)\n* ComboAggregateFactory.AggCount(java.lang.String)\n* ComboAggregateFactory.AggCountDistinct(java.lang.String...)\n* ComboAggregateFactory.AggDistinct(java.lang.String...)\n* ComboAggregateFactory.AggArray(java.lang.String...)\n* ComboAggregateFactory.AggSortedFirst(java.lang.String, java.lang.String...)\n* ComboAggregateFactory.AggSortedLast(java.lang.String, java.lang.String...)\n\nFor example, to produce a table with several aggregations on the LastPrice of a Trades table:\n ohlc=trades.by(AggCombo(AggFirst(\"Open=LastPrice\"), AggLast(\"Close=LastPrice\"), AggMax(\"High=LastPrice\"), AggMin(\"Low=LastPrice\"), AggSum(\"Volume=Size\"), AggWAvg(\"Size\", \"VWAP=LastPrice\"), \"Symbol\")",
 "typeName": "class"
}